<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Os X on Adam Israel</title>
    <link>http://dev.adamisrael.com/tags/os-x/</link>
    <description>Recent content in Os X on Adam Israel</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Dec 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://dev.adamisrael.com/tags/os-x/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>sshuttle workaround for OS X 10.10 (Yosemite), Juju and Vagrant</title>
      <link>http://dev.adamisrael.com/blog/2014/12/12/sshuttle-workaround-for-os-x-10-10-yosemite-juju-and-vagrant/</link>
      <pubDate>Fri, 12 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://dev.adamisrael.com/blog/2014/12/12/sshuttle-workaround-for-os-x-10-10-yosemite-juju-and-vagrant/</guid>
      <description>&lt;p class=&#34;p2&#34;&gt;
  &lt;a href=&#34;https://github.com/sshuttle/sshuttle&#34;&gt;sshuttle&lt;/a&gt; is a nifty little transparent proxy/vpn that works by tunneling TCP traffic over SSH, or more specifically, tearing down a TCP session and reassembling the data on the other side. I started using it earlier this year, as part of my workflow using &lt;a href=&#34;https://juju.ubuntu.com/&#34;&gt;Juju&lt;/a&gt; and developing under OS X. It&amp;#8217;s like a data center in a box, inside another box. Code locally in my editor of choice (vim, TextMate, and more recently, Atom). Deploy new code. Refresh web browser, thanks to sshuttle. With sshuttle, I could connect to the services running within my virtual machine running Ubuntu natively through OS X.
&lt;/p&gt;

&lt;p class=&#34;p2&#34;&gt;
  Until I upgraded to Yosemite (OS X 10.10).
&lt;/p&gt;

&lt;p class=&#34;p2&#34;&gt;
  ipfw, the FreeBSD ip packet filter, was replaced by OpenBSD&amp;#8217;s pf in OS X 10.7, but the binary lived on through 10.9. sshuttle has no support for pf, which led me googling down a spiraling trail of despair and hope that someone, some day, would patch sshuttle.
&lt;/p&gt;

&lt;p class=&#34;p2&#34;&gt;
  I&amp;#8217;m more familiar with iptables than either ipfw or pf, but I understand enough networking to know that ubuntu-in-a-virtual-machine was already setup to talk to the outside world. I figured that there must be something more obvious than setting up a poor man&amp;#8217;s VPN to talk to it.
&lt;/p&gt;

&lt;p class=&#34;p2&#34;&gt;
  A few hours of testing later, I had a working solution using the route command.
&lt;/p&gt;

&lt;pre class=&#34;lang:sh decode:true &#34;&gt;$ sudo route add -net 10.0.3.0/24 172.16.250.15&lt;/pre&gt;

&lt;p&gt;The lxc containers run on the 10.0.3.0 network, and the lxc host (always, in the official Vagrant image) has eth1 bound to 172.16.250.15.&lt;/p&gt;

&lt;p&gt;There&amp;#8217;s a few ways I could have implemented this. I could have made it a static route, always active, but that could lead to unintended side-effects if you were to join a network using the same ip range. Same logic rules out adding it to my ~/.bash_profile. I ended up finding vagrant-triggers, which allows you to run custom commands at various stages of the vagrant lifecycle. With that, I can add the route when I boot up a virtual machine, and remove it when I&amp;#8217;ve shut it down.&lt;/p&gt;

&lt;p class=&#34;p2&#34;&gt;
  While I can confirm that it works for me, I can&amp;#8217;t say how well it&amp;#8217;ll work for other use cases of sshuttle or earlier versions of OS X. Juju users can head over to the &lt;a href=&#34;https://juju.ubuntu.com/docs/howto-vagrant-workflow.html&#34;&gt;Vagrant Workflow&lt;/a&gt; docs for the latest and greatest, or read on for the &lt;a href=&#34;https://gist.github.com/AdamIsrael/cc51d3d704c18095f718&#34;&gt;gist&lt;/a&gt;.
&lt;/p&gt;

&lt;p class=&#34;p2&#34;&gt;
  
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p class=&#34;p3&#34;&gt;

&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Making OS X, Go, and Brew play happy</title>
      <link>http://dev.adamisrael.com/blog/2014/11/13/making-os-x-go-and-brew-play-happy/</link>
      <pubDate>Thu, 13 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://dev.adamisrael.com/blog/2014/11/13/making-os-x-go-and-brew-play-happy/</guid>
      <description>

&lt;h1 id=&#34;go-and-os-x:88ab873d5c8d53a90360c0026a04b5ae&#34;&gt;GO and OS X&lt;/h1&gt;

&lt;p&gt;I&amp;#8217;m doing a little hacking with &lt;a href=&#34;https://github.com/juju-actions/juju/wiki&#34;&gt;juju actions&lt;/a&gt; before they land in a stable release but I ran into some hurdles getting Go working with the &lt;a href=&#34;http://brew.sh/&#34;&gt;brew&lt;/a&gt;-installed version. Trying to install Go packages failed with a bunch of &amp;#8216;unrecognized import path&amp;#8217; errors. Here&amp;#8217;s how I fixed it.&lt;/p&gt;

&lt;h1 id=&#34;stop-go-stop:88ab873d5c8d53a90360c0026a04b5ae&#34;&gt;STOP, GO, STOP&lt;/h1&gt;

&lt;p&gt;Even though you can install Go via brew, there&amp;#8217;s more to be done to get it working. Go relies on two environment variables: [GOPATH][3], and GOROOT. GOROOT is the path where Go is installed, and GOPATH is the directory you&amp;#8217;ve created for your code workspace (which I&amp;#8217;ve defaulted to $HOME/go).  We then need to tell our shell where to find these installed executable and run them first&lt;sup&gt;&lt;a href=&#34;#1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang:default decode:true&#34; title=&#34;Add go to your bash profile&#34;&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; ~/.bash_profile
# Go go gadget Go!
GOVERSION=$(brew list go | head -n 1 | cut -d &#39;/&#39; -f 6)
export GOPATH=$HOME/go
export GOROOT=$(brew --prefix)/Cellar/go/$GOVERSION/libexec
PATH=$GOROOT/bin:&#34;${PATH}&#34;
EOF
&lt;/pre&gt;

&lt;p&gt;Now you can run something like to have easier access to docs:&lt;/p&gt;

&lt;pre class=&#34;theme:terminal lang:default decode:true&#34;&gt;$ go get code.google.com/p/go.tools/cmd/godoc
$ godoc gofmt
COMMAND DOCUMENTATION

    Gofmt formats Go programs. It uses tabs (width = 8) for indentation and
    blanks for alignment.

    Without an explicit path, it processes the standard input. Given a file,
    it operates on that file; given a directory, it operates on all .go
    files in that directory, recursively. (Files starting with a period are
    ignored.) By default, gofmt prints the reformatted sources to standard
    output.

    Usage:

    gofmt [flags] [path ...]

    The flags are:

    -d
        Do not print reformatted sources to standard output.
        If a file&#39;s formatting is different than gofmt&#39;s, print diffs
        to standard output.
    -e
        Print all (including spurious) errors.
    -l
        Do not print reformatted sources to standard output.
        If a file&#39;s formatting is different from gofmt&#39;s, print its name
        to standard output.
    -r rule
        Apply the rewrite rule to the source before reformatting.
    -s
        Try to simplify code (after applying the rewrite rule, if any).
    -w
        Do not print reformatted sources to standard output.
        If a file&#39;s formatting is different from gofmt&#39;s, overwrite it
        with gofmt&#39;s version.

    Debugging support:

    -cpuprofile filename
        Write cpu profile to the specified file.

    The rewrite rule specified with the -r flag must be a string of the
    form:

    pattern -&amp;gt; replacement

    Both pattern and replacement must be valid Go expressions. In the
    pattern, single-character lowercase identifiers serve as wildcards
    matching arbitrary sub-expressions; those expressions will be
    substituted for the same identifiers in the replacement.

    When gofmt reads from standard input, it accepts either a full Go
    program or a program fragment. A program fragment must be a
    syntactically valid declaration list, statement list, or expression.
    When formatting such a fragment, gofmt preserves leading indentation as
    well as leading and trailing spaces, so that individual sections of a Go
    program can be formatted by piping them through gofmt.

    Examples

    To check files for unnecessary parentheses:

    gofmt -r &#39;(a) -&amp;gt; a&#39; -l *.go

    To remove the parentheses:

    gofmt -r &#39;(a) -&amp;gt; a&#39; -w *.go

    To convert the package tree from explicit slice upper bounds to implicit
    ones:

    gofmt -r &#39;α[β:len(α)] -&amp;gt; α[β:]&#39; -w $GOROOT/src/pkg


    The simplify command

    When invoked with -s gofmt will make the following source
    transformations where possible.

    An array, slice, or map composite literal of the form:
        []T{T{}, T{}}
    will be simplified to:
        []T{{}, {}}

    A slice expression of the form:
        s[a:len(s)]
    will be simplified to:
        s[a:]

    A range of the form:
        for x, _ = range v {...}
    will be simplified to:
        for x = range v {...}

BUGS

   The implementation of -r is a bit slow.
&lt;/pre&gt;

&lt;h1 id=&#34;homebrew-gotchas:88ab873d5c8d53a90360c0026a04b5ae&#34;&gt;Homebrew Gotchas&lt;/h1&gt;

&lt;p&gt;Homebrew installs the go formula with a bin/ directory, which symlinks to the go and gofmt binaries in libexec/. Other binaries, such as godoc, will be installed to libexec but are not symlinked to bin/. Adding go/$GOVERSION/libexec, instead of go/$GOVERSION/bin, to PATH makes sure we&amp;#8217;re looking in the right place, and this setup will survive a version upgrade.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a name=&#34;1&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;1&lt;/sup&gt;: It would probably be better to create a script that would toggle the PATH to include/exclude my $GOPATH/bin in $PATH. I&amp;#8217;m using this to run the latest cutting edge version of juju, but I can see the need to switch back to using the released version of juju, without having to hack my ~/.bash_profile&lt;/p&gt;

&lt;p&gt;[3]: &lt;a href=&#34;https://code.google.com/p/go-wiki/wiki/GOPATH&#34;&gt;https://code.google.com/p/go-wiki/wiki/GOPATH&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Q&amp;A: Why is Scrivener using my old contact information?</title>
      <link>http://dev.adamisrael.com/blog/2014/07/31/qa-why-is-scrivener-using-my-old-contact-information/</link>
      <pubDate>Thu, 31 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://dev.adamisrael.com/blog/2014/07/31/qa-why-is-scrivener-using-my-old-contact-information/</guid>
      <description>&lt;p&gt;For the past few years, I&amp;#8217;ve had to manually update the contact information in the header of every [Scrivener][1] project I&amp;#8217;ve created. It was defaulting to an old email and physical address, but somehow had the correct phone number.&lt;/p&gt;

&lt;p&gt;Scrivener can pull your contact information from the OS X application &lt;em&gt;Contacts&lt;/em&gt;, if you add the string &amp;#8220;(Scrivener:UseMe)&amp;#8221; to the notes of your contact card. As it turns out, I had done that already but my card has all of my email addresses (work and home) as well as my current and past physical addresses. In that case, Scrivener just uses the first phone, email, and physical address it finds.&lt;/p&gt;

&lt;p&gt;The solution is simple, and doubly useful if you write under a pseudonym. Create a new contact card with the information you want in your manuscript&amp;#8217;s cover page. Don&amp;#8217;t forget to add &amp;#8220;(Scrivener:UseMe)&amp;#8221; to the notes section of your new contact, and remove it from the old.&lt;/p&gt;

&lt;p&gt;The next time you create a project in Scrivener, it will use your new contact.&lt;/p&gt;

&lt;p&gt;[1]: &lt;a href=&#34;http://www.literatureandlatte.com/scrivener.php&#34;&gt;http://www.literatureandlatte.com/scrivener.php&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>